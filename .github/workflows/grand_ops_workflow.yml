name: Grand Ops Unified Pipeline (Auto-Generate & Run)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  ops-execution:
    runs-on: ubuntu-latest
    
    steps:
      # 1. ì†ŒìŠ¤ ì½”ë“œ ì²´í¬ì•„ì›ƒ
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2. íŒŒì´ì¬ í™˜ê²½ ì„¤ì •
      - name: ğŸ Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'

      # 3. Docker Buildx ì„¤ì •
      - name: ğŸ³ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 4. [ëŒ€í†µí•©] ê´€ë¦¬ ìŠ¤í¬ë¦½íŠ¸ ìë™ ìƒì„± (OSê´€ë¦¬ + ë¹Œë“œ + ë¬´ì¤‘ë‹¨ ë°°í¬ + ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰)
      - name: ğŸ›  Generate Universal Ops Manager Script
        run: |
          cat << 'EOF' > universal_ops_manager.sh
          #!/bin/bash
          set -euo pipefail

          # --- CONFIGURATION ---
          WORKSPACE_DIR="${PWD}"
          DATA_DIR="${WORKSPACE_DIR}/data"
          CACHE_DIR="${WORKSPACE_DIR}/.cache"
          SCRIPTS_DIR="${WORKSPACE_DIR}/scripts"
          LOG_FILE="${DATA_DIR}/ops_execution.log"
          
          # Docker Config
          IMAGE_NAME="grand-ops-image"
          IMAGE_TAG="latest"
          APP_CONTAINER="grand-ops-core"
          DB_CONTAINER="grand-ops-db"

          # --- UTILS ---
          log() {
              timestamp=$(date "+%Y-%m-%d %H:%M:%S")
              echo -e "\033[0;32m[${timestamp}] [OPS]\033[0m $1"
              if [ -d "${DATA_DIR}" ]; then echo "[${timestamp}] [OPS] $1" >> "${LOG_FILE}"; fi
          }

          # --- 1. OS DETECTION & UPGRADE ---
          detect_and_upgrade_os() {
              log "ğŸ” Detecting OS..."
              if [ -f /etc/os-release ]; then . /etc/os-release; OS_NAME=$ID; else OS_NAME="unknown"; fi
              log "Detected OS: ${OS_NAME}"
              
              case "${OS_NAME}" in
                  ubuntu|debian)
                      sudo apt-get update -y ;;
                  alpine)
                      apk update ;;
                  centos|rhel)
                      # dnfë‚˜ yum í™•ì¸ í›„ ì—…ë°ì´íŠ¸ (í•„ìš”ì‹œ ì£¼ì„ í•´ì œ)
                      log "â„¹ï¸ RPM based system detected." ;;
                  *)
                      log "âš ï¸ Unknown OS. Skipping package updates." ;;
              esac
          }

          # --- 2. ENVIRONMENT SETUP ---
          setup_environment() {
              log "ğŸ›  Setting up directories..."
              mkdir -p "${DATA_DIR}" "${CACHE_DIR}" "${SCRIPTS_DIR}"
              touch "${CACHE_DIR}/last_run_$(date +%Y%m%d).lock"
              
              # Path ì„¤ì • (í˜„ì¬ ì‰˜ ì„¸ì…˜ìš©)
              export PATH="${SCRIPTS_DIR}:${PATH}"
              log "âœ… Directories ready & PATH updated."
          }

          # --- 3. DOCKER BUILD ---
          build_image() {
              if [ -f "Dockerfile" ]; then
                  log "ğŸ³ Building Docker Image..."
                  docker build -t "${IMAGE_NAME}:${IMAGE_TAG}" . || log "âš ï¸ Docker build warning"
              else
                  log "â„¹ï¸ No Dockerfile found. Skipping build."
              fi
          }

          # --- 4. CONTAINER DEPLOYMENT (NO STOP POLICY) ---
          # ì»¨í…Œì´ë„ˆ ì •ì§€/ì‚­ì œ ì—†ì´, ì—†ìœ¼ë©´ ìƒì„±í•˜ê³  êº¼ì ¸ìˆìœ¼ë©´ ì¼œëŠ” ë¡œì§
          deploy_services() {
              log "ğŸš€ Checking Services (Policy: Do NOT Stop Existing)..."

              # (A) DB Container Check
              if [ "$(docker ps -q -f name=${DB_CONTAINER})" ]; then
                  log "âœ… [DB] Service '${DB_CONTAINER}' is already running. Skipping."
              else
                  if [ "$(docker ps -aq -f status=exited -f name=${DB_CONTAINER})" ]; then
                      log "âš¡ [DB] Starting existing container..."
                      docker start ${DB_CONTAINER}
                  else
                      log "âœ¨ [DB] Creating new container..."
                      # ì˜ˆì‹œ: Postgres
                      docker run -d --name "${DB_CONTAINER}" \
                          --restart always \
                          -e POSTGRES_PASSWORD=securepass \
                          postgres:13-alpine || log "âš ï¸ DB creation failed"
                  fi
              fi

              # (B) App Container Check
              if [ "$(docker ps -q -f name=${APP_CONTAINER})" ]; then
                  log "âœ… [APP] Service '${APP_CONTAINER}' is already running. Skipping."
              else
                  if [ "$(docker ps -aq -f status=exited -f name=${APP_CONTAINER})" ]; then
                      log "âš¡ [APP] Starting existing container..."
                      docker start ${APP_CONTAINER}
                  else
                      # ì´ë¯¸ì§€ê°€ ìˆì„ ë•Œë§Œ ìƒì„±
                      if docker image inspect "${IMAGE_NAME}:${IMAGE_TAG}" > /dev/null 2>&1; then
                          log "âœ¨ [APP] Creating new container from built image..."
                          docker run -d --name "${APP_CONTAINER}" \
                              --restart always \
                              -v "${DATA_DIR}:/app/data" \
                              "${IMAGE_NAME}:${IMAGE_TAG}" || log "âš ï¸ App creation failed"
                      else
                          log "âŒ Image not found. Cannot start ${APP_CONTAINER}."
                      fi
                  fi
              fi
          }

          # --- 5. EXECUTE SCRIPTS ---
          run_scripts() {
              log "ğŸ“œ Executing scripts in ${SCRIPTS_DIR}..."
              if [ "$(ls -A ${SCRIPTS_DIR} 2>/dev/null)" ]; then
                  for script in "${SCRIPTS_DIR}"/*; do
                      [ -f "$script" ] || continue
                      filename=$(basename "$script")
                      log "â–¶ï¸ Running: $filename"
                      
                      if [[ "$filename" == *.sh ]]; then
                          chmod +x "$script"
                          bash "$script" || log "âŒ Script failed: $filename"
                      elif [[ "$filename" == *.py ]]; then
                          python3 "$script" || log "âŒ Script failed: $filename"
                      fi
                  done
              else
                  log "â„¹ï¸ No custom scripts found."
              fi
          }

          # --- MAIN ---
          main() {
              detect_and_upgrade_os
              setup_environment
              build_image
              deploy_services  # <--- ì¶”ê°€ëœ ì»¨í…Œì´ë„ˆ ë°°í¬ ë‹¨ê³„
              run_scripts
              log "ğŸ‰ All Operations Completed."
          }
          main
          EOF

      # 5. ê¶Œí•œ ë¶€ì—¬ ë° ì‹¤í–‰
      - name: ğŸš€ Run Universal Ops Manager
        run: |
          chmod +x ./universal_ops_manager.sh
          ./universal_ops_manager.sh
        env:
          TERM: xterm-256color

      # 6. Git ë™ê¸°í™” (ì—ëŸ¬ ë°©ì§€ ë¡œì§ ìœ ì§€)
      - name: ğŸ”„ Sync and Commit Infrastructure State
        if: always()
        run: |
          git config --global user.name "Grand-Ops-Bot"
          git config --global user.email "ops-bot@noreply.github.com"
          
          echo "ğŸ” Checking for artifacts..."
          # scripts í´ë”ë„ ë³€ê²½ì‚¬í•­ ê°ì§€ì— í¬í•¨
          git add data/ .cache/ config/ scripts/ || echo "Warning: Some paths not found"
          
          if git diff --staged --quiet; then
            echo "âœ… No changes to commit."
          else
            git commit -m "ops: auto-provision & container sync [skip ci]"
            
            echo "ğŸ”„ Handling remote changes (Rebase)..."
            git pull --rebase origin main || (git rebase --abort && git pull origin main --no-edit)
            
            echo "ğŸš€ Pushing final state..."
            git push origin main
          fi
