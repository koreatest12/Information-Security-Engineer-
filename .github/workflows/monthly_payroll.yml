name: Ultra-Secure DB Locking & Financial Ops

on:
  schedule:
    - cron: '0 18 * * 5' # Îß§Ï£º Í∏àÏöîÏùº Ïã§Ìñâ
  workflow_dispatch:

jobs:
  run-secure-db-locking-system:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read
      checks: write

    steps:
    - name: Checkout Main Repository
      uses: actions/checkout@v4
      with:
        path: main_repo

    # [Ïô∏Î∂Ä Î¶¨Ìè¨ÏßÄÌÜ†Î¶¨ ÌÜµÌï© Ïú†ÏßÄ]
    - name: Checkout External Security Assets
      uses: actions/checkout@v4
      continue-on-error: true
      with:
        repository: koreatest12/Information-Security-Engineer-
        path: external_assets
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install Dependencies
      run: |
        pip install pandas numpy cryptography schedule tabulate psutil openpyxl networkx pyzipper

    - name: Deploy Secure DB Ops Engine
      run: |
        mkdir -p main_repo/scripts
        cat << 'EOF' > main_repo/scripts/secure_db_ops.py
        import os
        import time
        import sqlite3
        import shutil
        import stat
        import schedule
        import pandas as pd
        import numpy as np
        import networkx as nx
        import pyzipper
        from datetime import datetime
        from cryptography.fernet import Fernet
        from tabulate import tabulate

        # ==========================================
        # 1. Configuration & Path Setup
        # ==========================================
        BASE_DIR = os.getcwd()
        EXT_REPO_DIR = os.path.join(BASE_DIR, '../external_assets')
        
        DIRS = {
            'SECURE_VAULT': os.path.join(BASE_DIR, 'SECURE_VAULT'),
            'DB_DATA': os.path.join(BASE_DIR, 'DATA/DB'),
            'EXTERNAL_SYNC': os.path.join(BASE_DIR, 'DATA/EXTERNAL_SYNC'),
            'LOGS': os.path.join(BASE_DIR, 'LOGS')
        }
        
        for d in DIRS.values():
            os.makedirs(d, exist_ok=True)

        # ==========================================
        # 2. Security Vault (Password Rotation) - Ïú†ÏßÄ
        # ==========================================
        class SecurityVault:
            def __init__(self):
                self.base_pin = 4310
                self.current_password = self._generate_weekly_password()

            def _generate_weekly_password(self):
                """Îß§Ï£º ÎπÑÎ∞ÄÎ≤àÌò∏ ÏûêÎèô Î≥ÄÍ≤Ω (4310 + Ï£ºÏ∞®)"""
                current_week = datetime.now().isocalendar()[1]
                rotated_pin = self.base_pin + current_week
                pwd = f"korea{rotated_pin}@#$"
                print(f"üîê [Vault] Password Rotated for Week {current_week}: korea****@#$")
                return pwd

            def encrypt_and_archive(self, target_dir, zip_name):
                zip_path = os.path.join(DIRS['SECURE_VAULT'], f"{zip_name}.zip")
                print(f"üõ°Ô∏è [Vault] Encrypting & Archiving: {zip_path}")
                try:
                    with pyzipper.AESZipFile(zip_path, 'w', compression=pyzipper.ZIP_LZMA, encryption=pyzipper.WZ_AES) as zf:
                        zf.setpassword(self.current_password.encode())
                        for root, _, files in os.walk(target_dir):
                            for file in files:
                                p = os.path.join(root, file)
                                zf.write(p, os.path.relpath(p, os.path.dirname(target_dir)))
                    return True
                except Exception as e:
                    print(f"   ‚ùå Encryption Failed: {e}")
                    return False

        # ==========================================
        # 3. Secure DB Manager (New: Lock Implementation)
        # ==========================================
        class SecureDBManager:
            def __init__(self, db_name="korea_financial_core.db"):
                self.db_path = os.path.join(DIRS['DB_DATA'], db_name)
                self.conn = None
                
            def create_db_and_tables(self):
                """[Í∏∞Îä• Î∞òÏòÅ] DB Î∞è ÌÖåÏù¥Î∏î ÏÉùÏÑ±"""
                print(f"\nüõ†Ô∏è [DB Admin] Initializing Database: {self.db_path}")
                self.conn = sqlite3.connect(self.db_path)
                
                # 1. Í∏àÏúµ Í±∞Îûò ÌÖåÏù¥Î∏î
                self.conn.execute('''CREATE TABLE IF NOT EXISTS fin_transactions (
                    tx_id TEXT PRIMARY KEY, user_id TEXT, amount REAL, 
                    tx_type TEXT, timestamp DATETIME)''')
                
                # 2. Í∞êÏÇ¨ Î°úÍ∑∏ ÌÖåÏù¥Î∏î
                self.conn.execute('''CREATE TABLE IF NOT EXISTS audit_log (
                    log_id INTEGER PRIMARY KEY AUTOINCREMENT, action TEXT, 
                    status TEXT, timestamp DATETIME)''')
                
                self.conn.close()
                return "DB Schema Created"

            def perform_transaction_with_table_lock(self):
                """[Í∏∞Îä• Î∞òÏòÅ] Table Lock (Transaction Exclusive Lock)"""
                print(f"üîí [DB Lock] Acquiring TABLE LOCK for Batch Insert...")
                
                try:
                    self.conn = sqlite3.connect(self.db_path)
                    cursor = self.conn.cursor()
                    
                    # [Table Lock ÏãúÎÆ¨Î†àÏù¥ÏÖò] Exclusive Î™®Îìú Ìä∏ÎûúÏû≠ÏÖò ÏãúÏûë
                    # SQLiteÎäî ÌååÏùº Í∏∞Î∞òÏù¥Îùº Ïù¥ Î™ÖÎ†πÏñ¥Í∞Ä Ïã§ÌñâÎêòÎäî ÎèôÏïà Îã§Î•∏ Ïó∞Í≤∞ÏùÄ Write Î∂àÍ∞Ä (Table Lock Ìö®Í≥º)
                    cursor.execute("BEGIN EXCLUSIVE TRANSACTION")
                    
                    # Îç∞Ïù¥ÌÑ∞ ÎåÄÎüâ ÏûÖÎ†•
                    data = []
                    for i in range(100):
                        data.append((f"TX_{time.time()}_{i}", f"USER_{i}", np.random.randint(1000,99999), "DEPOSIT", datetime.now()))
                    
                    cursor.executemany("INSERT INTO fin_transactions VALUES (?,?,?,?,?)", data)
                    print(f"   ‚Ü≥ [Insert] 100 Rows Inserted under Lock protection.")
                    
                    # Lock Ìï¥Ï†ú (Commit)
                    self.conn.commit()
                    print(f"üîì [DB Lock] Transaction Committed. TABLE LOCK Released.")
                    return "Batch Insert with Lock Success"
                    
                except Exception as e:
                    if self.conn: self.conn.rollback()
                    return f"Transaction Failed: {e}"
                finally:
                    if self.conn: self.conn.close()

            def apply_physical_db_lock(self):
                """[Í∏∞Îä• Î∞òÏòÅ] DB File Lock (OS Í∂åÌïú Î≥ÄÍ≤Ω - Read Only)"""
                print(f"\nüö´ [DB Admin] Applying PHYSICAL LOCK to Database File...")
                if os.path.exists(self.db_path):
                    # Í∂åÌïúÏùÑ 400 (Owner Read Only)ÏúºÎ°ú Î≥ÄÍ≤ΩÌïòÏó¨ Ïì∞Í∏∞ ÏõêÏ≤ú Ï∞®Îã®
                    os.chmod(self.db_path, stat.S_IRUSR)
                    
                    # ÌôïÏù∏
                    mode = stat.S_IMODE(os.stat(self.db_path).st_mode)
                    return f"DB File Locked (Permission: {oct(mode)}) - Write Access Denied"
                return "DB File Not Found"

        # ==========================================
        # 4. External Assets & Control-M
        # ==========================================
        class ExternalRepoManager:
            def __init__(self):
                self.sync_path = DIRS['EXTERNAL_SYNC']
            
            def sync(self):
                print(f"\nüåç [External] Syncing Assets...")
                if os.path.exists(EXT_REPO_DIR):
                    if os.path.exists(self.sync_path): shutil.rmtree(self.sync_path)
                    shutil.copytree(EXT_REPO_DIR, self.sync_path, dirs_exist_ok=True)
                    return "Assets Synced"
                else:
                    # Simulation Mock
                    with open(os.path.join(self.sync_path, "security_policy.pdf"), 'w') as f: f.write("MOCK")
                    return "Mock Assets Generated"

        class ControlM_Engine:
            def __init__(self):
                self.dag = nx.DiGraph()
            
            def add_job(self, name, func, deps=[]):
                self.dag.add_node(name, task=func)
                for d in deps: self.dag.add_edge(d, name)
            
            def run(self):
                print(f"\nüéÆ [Control-M] Starting Workflow...")
                try:
                    for job in nx.topological_sort(self.dag):
                        print(f"   ‚ñ∂Ô∏è {job}...")
                        res = self.dag.nodes[job]['task']()
                        print(f"      ‚úÖ {res}")
                except Exception as e:
                    print(f"   üö® Workflow Error: {e}")

        # ==========================================
        # 5. Main Execution Flow
        # ==========================================
        if __name__ == "__main__":
            print(">> [Init] System Starting...")
            
            vault = SecurityVault()
            db_mgr = SecureDBManager()
            ext_mgr = ExternalRepoManager()
            ctm = ControlM_Engine()
            
            # --- Workflow Definition ---
            
            # 1. Ïô∏Î∂Ä ÏûêÏÇ∞ ÎèôÍ∏∞Ìôî
            ctm.add_job("JOB_EXT_SYNC", ext_mgr.sync)
            
            # 2. DB Î∞è ÌÖåÏù¥Î∏î ÏÉùÏÑ± (Ï¥àÍ∏∞Ìôî)
            ctm.add_job("JOB_DB_CREATE", db_mgr.create_db_and_tables, deps=["JOB_EXT_SYNC"])
            
            # 3. Table LockÏùÑ Í±¥ ÏÉÅÌÉúÏóêÏÑú Ìä∏ÎûúÏû≠ÏÖò ÏàòÌñâ
            ctm.add_job("JOB_TX_WITH_LOCK", db_mgr.perform_transaction_with_table_lock, deps=["JOB_DB_CREATE"])
            
            # 4. Î™®Îì† ÏûëÏóÖ ÏôÑÎ£å ÌõÑ DB ÌååÏùº Î¨ºÎ¶¨Ï†Å Ïû†Í∏à (Write Î∞©ÏßÄ)
            ctm.add_job("JOB_DB_FREEZE", db_mgr.apply_physical_db_lock, deps=["JOB_TX_WITH_LOCK"])
            
            # 5. Ïû†Í∏¥ DBÏôÄ Ïô∏Î∂Ä ÏûêÏÇ∞ÏùÑ ÏïîÌò∏Ìôî Î∞±ÏóÖ
            def job_backup():
                targets = [DIRS['DB_DATA'], DIRS['EXTERNAL_SYNC']]
                res = []
                for t in targets:
                    name = f"SECURE_BK_{os.path.basename(t)}_{datetime.now().strftime('%Y%m%d')}"
                    if vault.encrypt_and_archive(t, name):
                        res.append(name)
                return f"Archived: {', '.join(res)}"

            ctm.add_job("JOB_FINAL_BACKUP", job_backup, deps=["JOB_DB_FREEZE"])
            
            # Run
            ctm.run()
            
            print(f"\n>> [Complete] DB Locked & Data Secured.")
        EOF

    - name: Run Secure DB Ops
      run: |
        cd main_repo
        python scripts/secure_db_ops.py

    - name: Upload Secured Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Secured-DB-Vault-${{ github.run_number }}
        path: main_repo/SECURE_VAULT/
        retention-days: 14
