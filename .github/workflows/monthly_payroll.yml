name: Total Financial System (Loan/Card/Core + CTMFW & Backup)

on:
  schedule:
    - cron: '0 9 11,21 * *' # ì •ê¸° ì‹¤í–‰
  workflow_dispatch:        # ìˆ˜ë™ ì‹¤í–‰

jobs:
  run-financial-core:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      checks: write

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install Dependencies
      run: |
        pip install pandas matplotlib reportlab openpyxl numpy cryptography tabulate schedule

    - name: Generate Financial System Script
      run: |
        cat << 'EOF' > financial_core.py
        import sqlite3
        import pandas as pd
        import os
        import time
        import shutil
        import schedule
        import numpy as np
        import hashlib
        from datetime import datetime
        from cryptography.fernet import Fernet
        from tabulate import tabulate

        # ==========================================
        # 1. Directory Structure (Channel & System)
        # ==========================================
        DIRS = {
            'CARD': 'INBOUND/CARD',      # ì¹´ë“œ ìŠ¹ì¸/ëŒ€ì¶œ
            'LOAN': 'INBOUND/LOAN',      # ì—¬ì‹  ì‹¤í–‰/ìƒí™˜
            'CORE': 'INBOUND/CORE',      # ìˆ˜ì‹  ì…ì¶œê¸ˆ
            'ARCHIVE': 'DATA/ARCHIVE',   # ì²˜ë¦¬ ì™„ë£Œ ë³´ê´€
            'BACKUP': 'DATA/BACKUP',     # DB ë°±ì—… ì €ì¥ì†Œ
            'REPORT': 'DATA/REPORT'      # ê²°ê³¼ ë¦¬í¬íŠ¸
        }
        for d in DIRS.values():
            if not os.path.exists(d): os.makedirs(d)

        # ==========================================
        # 2. Security Module (AES-256)
        # ==========================================
        class SecurityManager:
            def __init__(self):
                self.key = Fernet.generate_key()
                self.cipher = Fernet(self.key)
            
            def encrypt(self, text): 
                return self.cipher.encrypt(str(text).encode()).decode()
            
            def decrypt(self, text): 
                return self.cipher.decrypt(str(text).encode()).decode()
            
            def get_file_hash(self, filepath):
                sha = hashlib.sha256()
                with open(filepath, 'rb') as f:
                    sha.update(f.read())
                return sha.hexdigest()

        # ==========================================
        # 3. Financial DW Manager (Vertica Sim)
        # ==========================================
        class FinancialDW:
            def __init__(self, db_name="financial_dw.db"):
                self.conn = sqlite3.connect(db_name)
                self.cursor = self.conn.cursor()
                self.sec = SecurityManager()
                self._init_schema()

            def _init_schema(self):
                # 1) ì¹´ë“œ íŠ¸ëœì­ì…˜ (ìŠ¹ì¸/ì¹´ë“œë¡ )
                self.cursor.execute('''CREATE TABLE IF NOT EXISTS fact_card_tx (
                    tx_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    card_no_enc TEXT,
                    tx_type TEXT, -- APPROVAL, CARD_LOAN, CANCEL
                    merchant TEXT,
                    amount INTEGER,
                    approval_time TIMESTAMP
                )''')

                # 2) ì—¬ì‹ (ëŒ€ì¶œ) íŠ¸ëœì­ì…˜ (ì‹¤í–‰/ìƒí™˜)
                self.cursor.execute('''CREATE TABLE IF NOT EXISTS fact_loan_tx (
                    loan_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    cust_id_enc TEXT,
                    loan_type TEXT, -- MORTGAGE(ì£¼íƒ), CREDIT(ì‹ ìš©)
                    interest_rate REAL,
                    amount INTEGER,
                    tx_time TIMESTAMP
                )''')

                # 3) ìˆ˜ì‹ (Core) íŠ¸ëœì­ì…˜
                self.cursor.execute('''CREATE TABLE IF NOT EXISTS fact_core_tx (
                    core_id INTEGER PRIMARY KEY AUTOINCREMENT,
                    account_enc TEXT,
                    tx_type TEXT, -- DEPOSIT, WITHDRAW
                    amount INTEGER,
                    balance_after INTEGER,
                    tx_time TIMESTAMP
                )''')

                # 4) ë°°ì¹˜ ì‘ì—… ë¡œê·¸ (Control-M Log)
                self.cursor.execute('''CREATE TABLE IF NOT EXISTS sys_job_log (
                    job_id TEXT,
                    start_time TIMESTAMP,
                    end_time TIMESTAMP,
                    status TEXT,
                    target_file TEXT
                )''')
                self.conn.commit()

            def execute_backup(self):
                """DB ë°±ì—… ìˆ˜í–‰"""
                backup_file = os.path.join(DIRS['BACKUP'], f"FULL_BACKUP_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db")
                try:
                    # SQLite Online Backup API ì‚¬ìš©
                    bck = sqlite3.connect(backup_file)
                    self.conn.backup(bck)
                    bck.close()
                    return True, backup_file
                except Exception as e:
                    return False, str(e)

        # ==========================================
        # 4. Interface Simulator (File Generator)
        # ==========================================
        class InterfaceSimulator:
            """ê° ê¸ˆìœµ ì—…ë¬´ë³„ íŠ¸ëœì­ì…˜ íŒŒì¼ ìƒì„± ì‹œë®¬ë ˆì´í„°"""
            def gen_card_file(self):
                self._gen_file('CARD', 'CARD_TRX_', ['APPROVAL', 'CARD_LOAN'], 10)

            def gen_loan_file(self):
                self._gen_file('LOAN', 'LOAN_APP_', ['NEW_LOAN', 'REPAYMENT'], 5)

            def gen_core_file(self):
                self._gen_file('CORE', 'CORE_BANK_', ['DEPOSIT', 'WITHDRAW'], 20)

            def _gen_file(self, system, prefix, types, count):
                timestamp = datetime.now().strftime("%H%M%S")
                filename = f"{prefix}{timestamp}.dat"
                path = os.path.join(DIRS[system], filename)
                
                data = {
                    'type': [np.random.choice(types) for _ in range(count)],
                    'user': [f"User_{np.random.randint(1000,9999)}" for _ in range(count)],
                    'amount': np.random.randint(1, 100) * 10000
                }
                pd.DataFrame(data).to_csv(path, index=False)
                print(f"ğŸ“¡ [Interface] {system} ì‹œìŠ¤í…œì—ì„œ íŒŒì¼ ìˆ˜ì‹ ë¨: {filename}")

        # ==========================================
        # 5. CTMFW & Batch Jobs
        # ==========================================
        class BatchJobController:
            def __init__(self, dw):
                self.dw = dw

            def process_card_batch(self, filepath):
                """ì¹´ë“œ ì‹œìŠ¤í…œ ë°°ì¹˜: ìŠ¹ì¸ ë° ë‹¨ê¸°ëŒ€ì¶œ ì²˜ë¦¬"""
                df = pd.read_csv(filepath)
                data = []
                for _, row in df.iterrows():
                    enc_card = self.dw.sec.encrypt(row['user'])
                    data.append((enc_card, row['type'], 'Simulated_Merchant', row['amount'], datetime.now()))
                
                self.dw.cursor.executemany("INSERT INTO fact_card_tx (card_no_enc, tx_type, merchant, amount, approval_time) VALUES (?,?,?,?,?)", data)
                self.dw.conn.commit()
                return len(data)

            def process_loan_batch(self, filepath):
                """ì—¬ì‹  ì‹œìŠ¤í…œ ë°°ì¹˜: ëŒ€ì¶œ ì‹¤í–‰ ë° ì´ì ê³„ì‚°"""
                df = pd.read_csv(filepath)
                data = []
                for _, row in df.iterrows():
                    enc_cust = self.dw.sec.encrypt(row['user'])
                    rate = 5.5 if row['type'] == 'NEW_LOAN' else 0.0
                    data.append((enc_cust, row['type'], rate, row['amount'], datetime.now()))
                
                self.dw.cursor.executemany("INSERT INTO fact_loan_tx (cust_id_enc, loan_type, interest_rate, amount, tx_time) VALUES (?,?,?,?,?)", data)
                self.dw.conn.commit()
                return len(data)

            def process_core_batch(self, filepath):
                """ìˆ˜ì‹  ì‹œìŠ¤í…œ ë°°ì¹˜: ì…ì¶œê¸ˆ ì›ì¥ ë°˜ì˜"""
                df = pd.read_csv(filepath)
                data = []
                for _, row in df.iterrows():
                    enc_acc = self.dw.sec.encrypt(row['user'])
                    bal_after = 1000000 + row['amount'] # ì‹œë®¬ë ˆì´ì…˜ ì”ì•¡
                    data.append((enc_acc, row['type'], row['amount'], bal_after, datetime.now()))
                
                self.dw.cursor.executemany("INSERT INTO fact_core_tx (account_enc, tx_type, amount, balance_after, tx_time) VALUES (?,?,?,?,?)", data)
                self.dw.conn.commit()
                return len(data)

        class CTMFW_Engine:
            def __init__(self, dw, batch_ctrl):
                self.dw = dw
                self.batch = batch_ctrl

            def watch_files(self):
                # ê°ì‹œ ëŒ€ìƒ ì •ì˜ (ì‹œìŠ¤í…œ: (í´ë”, ë°°ì¹˜í•¨ìˆ˜, JobID))
                targets = [
                    ('CARD', DIRS['CARD'], self.batch.process_card_batch, 'JOB_CARD_001'),
                    ('LOAN', DIRS['LOAN'], self.batch.process_loan_batch, 'JOB_LOAN_001'),
                    ('CORE', DIRS['CORE'], self.batch.process_core_batch, 'JOB_CORE_001')
                ]

                for sys_name, folder, func, job_id in targets:
                    files = [f for f in os.listdir(folder) if f.endswith('.dat')]
                    
                    for f in files:
                        src = os.path.join(folder, f)
                        dst = os.path.join(DIRS['ARCHIVE'], f"{sys_name}_{f}")
                        
                        print(f"ğŸ‘ï¸ [CTMFW] {sys_name} íŒŒì¼ ê°ì§€: {f} -> ë°°ì¹˜ íŠ¸ë¦¬ê±°!")
                        start_time = datetime.now()
                        
                        try:
                            # 1. ë°°ì¹˜ ì‹¤í–‰
                            row_cnt = func(src)
                            status = "SUCCESS"
                            msg = f"Processed {row_cnt} rows"
                            
                            # 2. íŒŒì¼ ì´ë™ (Archiving)
                            shutil.move(src, dst)
                            
                        except Exception as e:
                            status = "FAIL"
                            msg = str(e)
                            print(f"   !! Error: {e}")

                        # 3. ë¡œê·¸ ê¸°ë¡
                        self.dw.cursor.execute("INSERT INTO sys_job_log VALUES (?,?,?,?,?)", 
                            (job_id, start_time, datetime.now(), status, f))
                        self.dw.conn.commit()
                        
                        # 4. ë°±ì—… íŠ¸ë¦¬ê±° (ë°ì´í„° ë³€ê²½ ë°œìƒ ì‹œ ìë™ ë°±ì—…)
                        if status == "SUCCESS":
                            self.trigger_backup()

            def trigger_backup(self):
                print("ğŸ’¾ [System] ë°ì´í„° ë³€ê²½ ê°ì§€ -> DB ë°±ì—… ë°°ì¹˜ ìˆ˜í–‰")
                res, path = self.dw.execute_backup()
                status = "SUCCESS" if res else "FAIL"
                self.dw.cursor.execute("INSERT INTO sys_job_log VALUES (?,?,?,?,?)",
                    ('JOB_DB_BACKUP', datetime.now(), datetime.now(), status, path))
                self.dw.conn.commit()
                if res: print(f"   >> ë°±ì—… ì™„ë£Œ: {os.path.basename(path)}")

        # ==========================================
        # 6. Main Orchestrator
        # ==========================================
        def print_dashboard(dw):
            print("\n" + "="*50)
            print(f"   FINANCIAL BATCH DASHBOARD ({datetime.now().strftime('%H:%M:%S')})")
            print("="*50)
            
            # Job ë¡œê·¸ ì¡°íšŒ
            df = pd.read_sql("SELECT job_id, status, target_file, end_time FROM sys_job_log ORDER BY end_time DESC LIMIT 5", dw.conn)
            if not df.empty:
                print(tabulate(df, headers='keys', tablefmt='psql', showindex=False))
            else:
                print("   (No Batch History)")
            print("\n")

        if __name__ == "__main__":
            print(">> [Init] ì°¨ì„¸ëŒ€ ê¸ˆìœµ ì‹œìŠ¤í…œ(Yeosin/Card/Core) ê°€ë™")
            
            dw = FinancialDW()
            batch_ctrl = BatchJobController(dw)
            ctmfw = CTMFW_Engine(dw, batch_ctrl)
            sim = InterfaceSimulator()
            
            # ìŠ¤ì¼€ì¤„ë§ ë“±ë¡
            # 1. ì¸í„°í˜ì´ìŠ¤ ì‹œë®¬ë ˆì´ì…˜ (ê°ê¸° ë‹¤ë¥¸ ì£¼ê¸°ë¡œ íŒŒì¼ ì „ì†¡)
            schedule.every(3).seconds.do(sim.gen_core_file)  # ìˆ˜ì‹ ì€ ë¹ˆë²ˆí•¨
            schedule.every(7).seconds.do(sim.gen_card_file)  # ì¹´ë“œëŠ” ì¤‘ê°„
            schedule.every(12).seconds.do(sim.gen_loan_file) # ì—¬ì‹ ì€ ê°€ë” ë°œìƒ
            
            # 2. CTMFW (1ì´ˆë§ˆë‹¤ ëª¨ë“  í´ë” ê°ì‹œ)
            schedule.every(1).seconds.do(ctmfw.watch_files)
            
            # 3. ëŒ€ì‹œë³´ë“œ ì¶œë ¥
            schedule.every(5).seconds.do(lambda: print_dashboard(dw))
            
            # ë©”ì¸ ë£¨í”„ (GitHub Actions íƒ€ì„ì•„ì›ƒ ê³ ë ¤ 60ì´ˆ)
            start = time.time()
            while time.time() - start < 60:
                schedule.run_pending()
                time.sleep(1)
            
            # ì¢…ë£Œ ì „ ìµœì¢… ì›ì¥ ì—‘ì…€ ì €ì¥
            print(">> [Shutdown] ì‹œìŠ¤í…œ ì¢…ë£Œ. ìµœì¢… ë¦¬í¬íŠ¸ ìƒì„±.")
            for table in ['fact_card_tx', 'fact_loan_tx', 'fact_core_tx', 'sys_job_log']:
                pd.read_sql(f"SELECT * FROM {table}", dw.conn).to_excel(f"{DIRS['REPORT']}/{table}.xlsx")
        EOF

    - name: Run Financial System
      run: python financial_core.py

    - name: Upload Financial Artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Financial-System-Data-${{ github.run_id }}
        path: |
          DATA/REPORT/
          DATA/BACKUP/
          DATA/ARCHIVE/
        retention-days: 30
