name: Bulk Script Health Check
run-name: 🛡️ 무중단 대량 스크립트 점검

on:
  schedule:
    - cron: '0 0 * * *' # 매일 한국 시간 오전 9시
  workflow_dispatch:      # 수동 실행 가능

jobs:
  bulk-execution:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
          cache: 'pip'

      # 1. 의존성 설치 (requirements.txt가 있다면)
      - name: Install Dependencies
        run: |
          if [ -f scripts/requirements.txt ]; then
            pip install -r scripts/requirements.txt
          else
            echo "::warning::scripts/requirements.txt not found. Running without extra dependencies."
          fi

      # 2. 실행 권한 부여
      - name: Grant Execute Permissions
        run: chmod -R +x scripts/

      # 3. 대량 스크립트 실행 (에러 발생 시에도 멈추지 않도록 수정됨)
      - name: Run All Scripts Recursively
        id: execution_step
        shell: bash
        run: |
          # [중요] 에러가 발생해도 쉘이 꺼지지 않게 설정 (set +e)
          set +e
          
          # 로그 디렉토리 준비
          mkdir -p execution_logs
          
          # GitHub Summary 헤더
          echo "## 📊 실행 결과 리포트" >> $GITHUB_STEP_SUMMARY
          echo "| 파일명 | 상태 | 시간 | 결과 메시지 |" >> $GITHUB_STEP_SUMMARY
          echo "| :--- | :---: | :---: | :--- |" >> $GITHUB_STEP_SUMMARY
          
          SUCCESS_COUNT=0
          FAILED_COUNT=0
          
          # 스크립트 파일 찾기 (하위 폴더 포함)
          # while 루프를 사용하여 파일 하나씩 처리
          find scripts -type f \( -name "*.py" -o -name "*.sh" \) | sort | while read -r file; do
            
            FILENAME=$(basename "$file")
            # 로그 파일 경로 설정
            LOG_FILE="execution_logs/${FILENAME}.log"
            
            echo "▶️ Running: $file"
            
            START=$(date +%s)
            
            # --- 실행부 ---
            # 여기서 에러가 나도 set +e 덕분에 멈추지 않습니다.
            if [[ "$file" == *.py ]]; then
              timeout 300s python "$file" > "$LOG_FILE" 2>&1
            else
              timeout 300s "$file" > "$LOG_FILE" 2>&1
            fi
            
            # 직전 명령의 종료 코드 캡처
            EXIT_CODE=$?
            # -------------
            
            END=$(date +%s)
            DURATION=$((END - START))
            
            # 결과 처리
            if [ $EXIT_CODE -eq 0 ]; then
              echo "  ✅ Success"
              echo "| $FILENAME | ✅ 성공 | ${DURATION}s | Pass |" >> $GITHUB_STEP_SUMMARY
              SUCCESS_COUNT=$((SUCCESS_COUNT+1))
              rm -f "$LOG_FILE" # 성공 시 로그 삭제
            elif [ $EXIT_CODE -eq 124 ]; then
              echo "  ⏰ Timeout"
              echo "| $FILENAME | ⏰ 타임아웃 | 300s+ | 5분 초과 중단 |" >> $GITHUB_STEP_SUMMARY
              FAILED_COUNT=$((FAILED_COUNT+1))
            else
              echo "  ❌ Failed (Code: $EXIT_CODE)"
              # 로그 마지막 줄을 요약에 표시 (특수문자 제거)
              ERR_MSG=$(tail -n 1 "$LOG_FILE" | tr -cd '\11\12\15\40-\176' | cut -c 1-50)
              echo "| $FILENAME | ❌ 실패 | ${DURATION}s | \`$ERR_MSG...\` |" >> $GITHUB_STEP_SUMMARY
              FAILED_COUNT=$((FAILED_COUNT+1))
            fi
            
          done
          
          # 총계를 파일에 저장 (환경변수 전달용)
          echo "FAILED_TOTAL=$FAILED_COUNT" >> $GITHUB_ENV
          
          echo "✅ 점검 완료. 성공: $SUCCESS_COUNT, 실패: $FAILED_COUNT"
          
          # set +e 상태라도 명시적으로 true를 반환하여 이 '단계(step)' 자체는 성공으로 마킹
          # (실패 여부는 아래 Finalize 단계에서 결정)
          exit 0

      # 4. 최종 상태 결정 (실패한 게 하나라도 있으면 여기서 워크플로우 실패 처리)
      - name: Finalize Status
        if: always() # 위 단계가 혹시라도 터져도 실행 보장
        run: |
          FAILED=${{ env.FAILED_TOTAL }}
          if [ -z "$FAILED" ]; then FAILED=0; fi
          
          if [ "$FAILED" -gt 0 ]; then
            echo "::error::총 $FAILED 개의 스크립트가 실패했습니다. 로그를 확인하세요."
            exit 1
          else
            echo "🎉 모든 스크립트가 정상적으로 실행되었습니다."
            exit 0
          fi

      # 5. 실패 로그 업로드
      - name: Upload Failure Logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: failed-logs-report
          path: execution_logs/
          retention-days: 3
